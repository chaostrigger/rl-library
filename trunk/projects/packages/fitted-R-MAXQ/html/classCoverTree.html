<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Fitted R-MAXQ: CoverTree&lt; T, Metric &gt; Class Template Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.7 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li id="current"><a href="annotated.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="dirs.html"><span>Directories</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
    <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
  </ul></div>
<h1>CoverTree&lt; T, Metric &gt; Class Template Reference</h1><!-- doxytag: class="CoverTree" -->Container for data of type T that supports searches for nearest neighbors, using a distance function object of type Metric.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;<a class="el" href="covertree_8hh-source.html">covertree.hh</a>&gt;</code>
<p>
<a href="classCoverTree-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCoverTree.html#68b3308c2125a2e56dde715d4311f2bc">CoverTree</a> (bool <a class="el" href="classCoverTree.html#233fd62ce4a1995d5990d51375df2fe8">duplicate</a>=false)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCoverTree.html#2dcbe4c90b7b8eed8c7fa629cc307afb">CoverTree</a> (const Metric &amp;<a class="el" href="classCoverTree.html#edb5f327de8b9407fcd533b4ef805bae">d</a>, bool <a class="el" href="classCoverTree.html#233fd62ce4a1995d5990d51375df2fe8">duplicate</a>=false)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCoverTree.html#04c3cb10fd17ac4bc72d432847f31a33">CoverTree</a> (const <a class="el" href="classCoverTree.html">CoverTree</a> &amp;other)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy constructor.  <a href="#04c3cb10fd17ac4bc72d432847f31a33"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCoverTree.html#84c299c990d7ae7a4bb2e50110894558">~CoverTree</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classCoverTree.html">CoverTree</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCoverTree.html#105988edb289fbb32d35692f02dce404">operator=</a> (const <a class="el" href="classCoverTree.html">CoverTree</a> &amp;other)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assignment operator.  <a href="#105988edb289fbb32d35692f02dce404"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const T &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCoverTree.html#7c70a6b8fa6a574215738febb30c3c76">insert</a> (const T &amp;x)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Inserts a new point into the cover tree.  <a href="#7c70a6b8fa6a574215738febb30c3c76"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCoverTree.html#a238543ae3c09e0ca49afb546620a174">remove</a> (const T &amp;x)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Removes one point, if it exists.  <a href="#a238543ae3c09e0ca49afb546620a174"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class OutputIterator&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">OutputIterator&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCoverTree.html#c4bf97dbf685cded2a10b27ea9c4acc7">nearest</a> (OutputIterator out, const T &amp;x, unsigned k)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find the k nearest neighbors (and their distances).  <a href="#c4bf97dbf685cded2a10b27ea9c4acc7"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class OutputIterator&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">OutputIterator&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCoverTree.html#3122ea91e16147fe835ec8030d9a3dcd">neighbors</a> (OutputIterator out, const T &amp;x, double margin) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find all instances within a certain radius.  <a href="#3122ea91e16147fe835ec8030d9a3dcd"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class OutputIterator&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">OutputIterator&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCoverTree.html#b16fa12d011a72f21faaa99c3df0f225">contents</a> (OutputIterator out) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Output all the instances in the cover tree.  <a href="#b16fa12d011a72f21faaa99c3df0f225"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCoverTree.html#0f107202bab8bcd71cee70e8113983fe">print</a> (std::ostream &amp;out) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write the tree structure to an output stream.  <a href="#0f107202bab8bcd71cee70e8113983fe"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCoverTree.html#efd767e3b2c2234f71daa7afaaafa215">clear</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove all instances from the tree.  <a href="#efd767e3b2c2234f71daa7afaaafa215"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structCoverTree_1_1Node.html">Node</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCoverTree.html#c792d7a8b75ba416bc84651ac797a50b">insert_node</a> (const T &amp;x)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Inserts a new point into the cover tree.  <a href="#c792d7a8b75ba416bc84651ac797a50b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCoverTree.html#6fe46129c552016a82ea130c5e1c8809">move_children</a> (<a class="el" href="structCoverTree_1_1Node.html">Node</a> &amp;parent)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add back to the tree the children of a just-deleted node.  <a href="#6fe46129c552016a82ea130c5e1c8809"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCoverTree.html#463f96b57029ba999c59f6e2a178a449">remove_recursive</a> (const T &amp;x, <a class="el" href="structCoverTree_1_1Node.html">Node</a> &amp;node)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove an instance from a subtree.  <a href="#463f96b57029ba999c59f6e2a178a449"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class OutputIterator&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">OutputIterator&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCoverTree.html#ddbb02ad4dd0b3158352a353e5227ebc">recursive_neighbors</a> (OutputIterator out, const T &amp;x, double margin, const <a class="el" href="structCoverTree_1_1Node.html">Node</a> &amp;node) const </td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class OutputIterator&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">OutputIterator&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCoverTree.html#7089bd56b538134d32338e577ceff9ac">recursive_contents</a> (OutputIterator out, const <a class="el" href="structCoverTree_1_1Node.html">Node</a> &amp;node) const </td></tr>

<tr><td colspan="2"><br><h2>Static Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCoverTree.html#24e09034d4a8f544ab25bf389fda604b">print</a> (std::ostream &amp;out, const <a class="el" href="structCoverTree_1_1Node.html">Node</a> *node)</td></tr>

<tr><td colspan="2"><br><h2>Private Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structCoverTree_1_1Node.html">Node</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCoverTree.html#e1e8f8eaedc4b7b385a41d6ca26db9fc">root</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">Metric&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCoverTree.html#edb5f327de8b9407fcd533b4ef805bae">d</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCoverTree.html#233fd62ce4a1995d5990d51375df2fe8">duplicate</a></td></tr>

<tr><td colspan="2"><br><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCoverTree_1_1LinkData.html">LinkData</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Object that tracks the iteration through a Node's list of children.  <a href="structCoverTree_1_1LinkData.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCoverTree_1_1Node.html">Node</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Representation of an individual instance.  <a href="structCoverTree_1_1Node.html#_details">More...</a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;class T, class Metric&gt;<br>
 class CoverTree&lt; T, Metric &gt;</h3>

Container for data of type T that supports searches for nearest neighbors, using a distance function object of type Metric. 
<p>

<p>
Definition at line <a class="el" href="covertree_8hh-source.html#l00018">18</a> of file <a class="el" href="covertree_8hh-source.html">covertree.hh</a>.<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="68b3308c2125a2e56dde715d4311f2bc"></a><!-- doxytag: member="CoverTree::CoverTree" ref="68b3308c2125a2e56dde715d4311f2bc" args="(bool duplicate=false)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class Metric&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCoverTree.html">CoverTree</a>&lt; T, Metric &gt;::<a class="el" href="classCoverTree.html">CoverTree</a>           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>duplicate</em> = <code>false</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>duplicate</em>&nbsp;</td><td>Whether to add an instance that is at distance 0 from an existing instance. </td></tr>
  </table>
</dl>

<p>
Definition at line <a class="el" href="covertree_8hh-source.html#l00087">87</a> of file <a class="el" href="covertree_8hh-source.html">covertree.hh</a>.
</div>
</div><p>
<a class="anchor" name="2dcbe4c90b7b8eed8c7fa629cc307afb"></a><!-- doxytag: member="CoverTree::CoverTree" ref="2dcbe4c90b7b8eed8c7fa629cc307afb" args="(const Metric &amp;d, bool duplicate=false)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class Metric&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCoverTree.html">CoverTree</a>&lt; T, Metric &gt;::<a class="el" href="classCoverTree.html">CoverTree</a>           </td>
          <td>(</td>
          <td class="paramtype">const Metric &amp;&nbsp;</td>
          <td class="paramname"> <em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>duplicate</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>d</em>&nbsp;</td><td>The distance metric to use. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>duplicate</em>&nbsp;</td><td>Whether to add an instance that is at distance 0 from an existing instance. </td></tr>
  </table>
</dl>

<p>
Definition at line <a class="el" href="covertree_8hh-source.html#l00094">94</a> of file <a class="el" href="covertree_8hh-source.html">covertree.hh</a>.
</div>
</div><p>
<a class="anchor" name="04c3cb10fd17ac4bc72d432847f31a33"></a><!-- doxytag: member="CoverTree::CoverTree" ref="04c3cb10fd17ac4bc72d432847f31a33" args="(const CoverTree &amp;other)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class Metric&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCoverTree.html">CoverTree</a>&lt; T, Metric &gt;::<a class="el" href="classCoverTree.html">CoverTree</a>           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCoverTree.html">CoverTree</a>&lt; T, Metric &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Copy constructor. 
<p>
Assumes that T and Metric are copyable. 
<p>
Definition at line <a class="el" href="covertree_8hh-source.html#l00099">99</a> of file <a class="el" href="covertree_8hh-source.html">covertree.hh</a>.
</div>
</div><p>
<a class="anchor" name="84c299c990d7ae7a4bb2e50110894558"></a><!-- doxytag: member="CoverTree::~CoverTree" ref="84c299c990d7ae7a4bb2e50110894558" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class Metric&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCoverTree.html">CoverTree</a>&lt; T, Metric &gt;::~<a class="el" href="classCoverTree.html">CoverTree</a>           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>
Definition at line <a class="el" href="covertree_8hh-source.html#l00105">105</a> of file <a class="el" href="covertree_8hh-source.html">covertree.hh</a>.
</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="efd767e3b2c2234f71daa7afaaafa215"></a><!-- doxytag: member="CoverTree::clear" ref="efd767e3b2c2234f71daa7afaaafa215" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class Metric&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classCoverTree.html">CoverTree</a>&lt; T, Metric &gt;::clear           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Remove all instances from the tree. 
<p>

<p>
Definition at line <a class="el" href="covertree_8hh-source.html#l00272">272</a> of file <a class="el" href="covertree_8hh-source.html">covertree.hh</a>.
</div>
</div><p>
<a class="anchor" name="b16fa12d011a72f21faaa99c3df0f225"></a><!-- doxytag: member="CoverTree::contents" ref="b16fa12d011a72f21faaa99c3df0f225" args="(OutputIterator out) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class Metric&gt; </div>
<div class="memtemplate">
template&lt;class OutputIterator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OutputIterator <a class="el" href="classCoverTree.html">CoverTree</a>&lt; T, Metric &gt;::contents           </td>
          <td>(</td>
          <td class="paramtype">OutputIterator&nbsp;</td>
          <td class="paramname"> <em>out</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Output all the instances in the cover tree. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>out</em>&nbsp;</td><td>An output iterator into which to write the results. The value_type of this iterator must be T. </td></tr>
  </table>
</dl>

<p>
Definition at line <a class="el" href="covertree_8hh-source.html#l00254">254</a> of file <a class="el" href="covertree_8hh-source.html">covertree.hh</a>.
</div>
</div><p>
<a class="anchor" name="7c70a6b8fa6a574215738febb30c3c76"></a><!-- doxytag: member="CoverTree::insert" ref="7c70a6b8fa6a574215738febb30c3c76" args="(const T &amp;x)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class Metric&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; <a class="el" href="classCoverTree.html">CoverTree</a>&lt; T, Metric &gt;::insert           </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Inserts a new point into the cover tree. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>The point to insert </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The inserted instance, or if this <a class="el" href="classCoverTree.html">CoverTree</a> does not insert duplicates, an existing instance at distance 0 from x </dd></dl>

<p>
Definition at line <a class="el" href="covertree_8hh-source.html#l00122">122</a> of file <a class="el" href="covertree_8hh-source.html">covertree.hh</a>.
</div>
</div><p>
<a class="anchor" name="c792d7a8b75ba416bc84651ac797a50b"></a><!-- doxytag: member="CoverTree::insert_node" ref="c792d7a8b75ba416bc84651ac797a50b" args="(const T &amp;x)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class Metric&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structCoverTree_1_1Node.html">Node</a>* <a class="el" href="classCoverTree.html">CoverTree</a>&lt; T, Metric &gt;::insert_node           </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Inserts a new point into the cover tree. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>The point to insert </td></tr>
  </table>
</dl>

<p>
Definition at line <a class="el" href="covertree_8hh-source.html#l00280">280</a> of file <a class="el" href="covertree_8hh-source.html">covertree.hh</a>.
<p>
Referenced by <a class="el" href="covertree_8hh-source.html#l00122">CoverTree&lt; boost::shared_ptr&lt; const StateVector &gt;, DistanceFunction &gt;::insert()</a>, and <a class="el" href="covertree_8hh-source.html#l00362">CoverTree&lt; boost::shared_ptr&lt; const StateVector &gt;, DistanceFunction &gt;::move_children()</a>.
</div>
</div><p>
<a class="anchor" name="6fe46129c552016a82ea130c5e1c8809"></a><!-- doxytag: member="CoverTree::move_children" ref="6fe46129c552016a82ea130c5e1c8809" args="(Node &amp;parent)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class Metric&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classCoverTree.html">CoverTree</a>&lt; T, Metric &gt;::move_children           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCoverTree_1_1Node.html">Node</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>parent</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Add back to the tree the children of a just-deleted node. 
<p>

<p>
Definition at line <a class="el" href="covertree_8hh-source.html#l00362">362</a> of file <a class="el" href="covertree_8hh-source.html">covertree.hh</a>.
<p>
Referenced by <a class="el" href="covertree_8hh-source.html#l00362">CoverTree&lt; boost::shared_ptr&lt; const StateVector &gt;, DistanceFunction &gt;::move_children()</a>, <a class="el" href="covertree_8hh-source.html#l00129">CoverTree&lt; boost::shared_ptr&lt; const StateVector &gt;, DistanceFunction &gt;::remove()</a>, and <a class="el" href="covertree_8hh-source.html#l00376">CoverTree&lt; boost::shared_ptr&lt; const StateVector &gt;, DistanceFunction &gt;::remove_recursive()</a>.
</div>
</div><p>
<a class="anchor" name="c4bf97dbf685cded2a10b27ea9c4acc7"></a><!-- doxytag: member="CoverTree::nearest" ref="c4bf97dbf685cded2a10b27ea9c4acc7" args="(OutputIterator out, const T &amp;x, unsigned k)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class Metric&gt; </div>
<div class="memtemplate">
template&lt;class OutputIterator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OutputIterator <a class="el" href="classCoverTree.html">CoverTree</a>&lt; T, Metric &gt;::nearest           </td>
          <td>(</td>
          <td class="paramtype">OutputIterator&nbsp;</td>
          <td class="paramname"> <em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>k</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Find the k nearest neighbors (and their distances). 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>out</em>&nbsp;</td><td>An output iterator into which to write the results. The value_type of this iterator must be std::pair&lt;double, T&gt;. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>The instance whose neighbors to find </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>k</em>&nbsp;</td><td>The number of neighbors to find. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The output iterator incremented (and written) up to k times. The nearest instance will be written first. </dd></dl>

<p>
Definition at line <a class="el" href="covertree_8hh-source.html#l00151">151</a> of file <a class="el" href="covertree_8hh-source.html">covertree.hh</a>.
<p>
Referenced by <a class="el" href="covertree_8hh-source.html#l00151">CoverTree&lt; boost::shared_ptr&lt; const StateVector &gt;, DistanceFunction &gt;::nearest()</a>.
</div>
</div><p>
<a class="anchor" name="3122ea91e16147fe835ec8030d9a3dcd"></a><!-- doxytag: member="CoverTree::neighbors" ref="3122ea91e16147fe835ec8030d9a3dcd" args="(OutputIterator out, const T &amp;x, double margin) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class Metric&gt; </div>
<div class="memtemplate">
template&lt;class OutputIterator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OutputIterator <a class="el" href="classCoverTree.html">CoverTree</a>&lt; T, Metric &gt;::neighbors           </td>
          <td>(</td>
          <td class="paramtype">OutputIterator&nbsp;</td>
          <td class="paramname"> <em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>margin</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Find all instances within a certain radius. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>out</em>&nbsp;</td><td>An output iterator into which to write the results. The value_type of this iterator must be std::pair&lt;double, T&gt;. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>The instance whose neighbors to find </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>margin</em>&nbsp;</td><td>The search radius. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The output iterator incremented (and written) once for each instance with the search radius. The instances are not written in any guaranteed order. </dd></dl>

<p>
Definition at line <a class="el" href="covertree_8hh-source.html#l00241">241</a> of file <a class="el" href="covertree_8hh-source.html">covertree.hh</a>.
</div>
</div><p>
<a class="anchor" name="105988edb289fbb32d35692f02dce404"></a><!-- doxytag: member="CoverTree::operator=" ref="105988edb289fbb32d35692f02dce404" args="(const CoverTree &amp;other)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class Metric&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCoverTree.html">CoverTree</a>&amp; <a class="el" href="classCoverTree.html">CoverTree</a>&lt; T, Metric &gt;::operator=           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCoverTree.html">CoverTree</a>&lt; T, Metric &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Assignment operator. 
<p>
Assumes that T and Metric are assignable. 
<p>
Definition at line <a class="el" href="covertree_8hh-source.html#l00110">110</a> of file <a class="el" href="covertree_8hh-source.html">covertree.hh</a>.
</div>
</div><p>
<a class="anchor" name="24e09034d4a8f544ab25bf389fda604b"></a><!-- doxytag: member="CoverTree::print" ref="24e09034d4a8f544ab25bf389fda604b" args="(std::ostream &amp;out, const Node *node)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class Metric&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classCoverTree.html">CoverTree</a>&lt; T, Metric &gt;::print           </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structCoverTree_1_1Node.html">Node</a> *&nbsp;</td>
          <td class="paramname"> <em>node</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline, static, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>
Definition at line <a class="el" href="covertree_8hh-source.html#l00439">439</a> of file <a class="el" href="covertree_8hh-source.html">covertree.hh</a>.
</div>
</div><p>
<a class="anchor" name="0f107202bab8bcd71cee70e8113983fe"></a><!-- doxytag: member="CoverTree::print" ref="0f107202bab8bcd71cee70e8113983fe" args="(std::ostream &amp;out) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class Metric&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classCoverTree.html">CoverTree</a>&lt; T, Metric &gt;::print           </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>out</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Write the tree structure to an output stream. 
<p>
Each line of the output will contain three tab-separated entries, describing a link in the tree. The first entry is the level at which the link occurs. The second and third entries give the parent and child instance values, respectively. This method therefore outputs n - 1 lines, where n is the number of instances. It assumes that operator&lt;&lt; is defined for T. 
<p>
Definition at line <a class="el" href="covertree_8hh-source.html#l00265">265</a> of file <a class="el" href="covertree_8hh-source.html">covertree.hh</a>.
<p>
Referenced by <a class="el" href="covertree_8hh-source.html#l00265">CoverTree&lt; boost::shared_ptr&lt; const StateVector &gt;, DistanceFunction &gt;::print()</a>.
</div>
</div><p>
<a class="anchor" name="7089bd56b538134d32338e577ceff9ac"></a><!-- doxytag: member="CoverTree::recursive_contents" ref="7089bd56b538134d32338e577ceff9ac" args="(OutputIterator out, const Node &amp;node) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class Metric&gt; </div>
<div class="memtemplate">
template&lt;class OutputIterator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OutputIterator <a class="el" href="classCoverTree.html">CoverTree</a>&lt; T, Metric &gt;::recursive_contents           </td>
          <td>(</td>
          <td class="paramtype">OutputIterator&nbsp;</td>
          <td class="paramname"> <em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structCoverTree_1_1Node.html">Node</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>node</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const<code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>
Definition at line <a class="el" href="covertree_8hh-source.html#l00429">429</a> of file <a class="el" href="covertree_8hh-source.html">covertree.hh</a>.
<p>
Referenced by <a class="el" href="covertree_8hh-source.html#l00254">CoverTree&lt; boost::shared_ptr&lt; const StateVector &gt;, DistanceFunction &gt;::contents()</a>, and <a class="el" href="covertree_8hh-source.html#l00429">CoverTree&lt; boost::shared_ptr&lt; const StateVector &gt;, DistanceFunction &gt;::recursive_contents()</a>.
</div>
</div><p>
<a class="anchor" name="ddbb02ad4dd0b3158352a353e5227ebc"></a><!-- doxytag: member="CoverTree::recursive_neighbors" ref="ddbb02ad4dd0b3158352a353e5227ebc" args="(OutputIterator out, const T &amp;x, double margin, const Node &amp;node) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class Metric&gt; </div>
<div class="memtemplate">
template&lt;class OutputIterator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OutputIterator <a class="el" href="classCoverTree.html">CoverTree</a>&lt; T, Metric &gt;::recursive_neighbors           </td>
          <td>(</td>
          <td class="paramtype">OutputIterator&nbsp;</td>
          <td class="paramname"> <em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>margin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structCoverTree_1_1Node.html">Node</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>node</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const<code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>
Definition at line <a class="el" href="covertree_8hh-source.html#l00411">411</a> of file <a class="el" href="covertree_8hh-source.html">covertree.hh</a>.
<p>
Referenced by <a class="el" href="covertree_8hh-source.html#l00241">CoverTree&lt; boost::shared_ptr&lt; const StateVector &gt;, DistanceFunction &gt;::neighbors()</a>, and <a class="el" href="covertree_8hh-source.html#l00411">CoverTree&lt; boost::shared_ptr&lt; const StateVector &gt;, DistanceFunction &gt;::recursive_neighbors()</a>.
</div>
</div><p>
<a class="anchor" name="a238543ae3c09e0ca49afb546620a174"></a><!-- doxytag: member="CoverTree::remove" ref="a238543ae3c09e0ca49afb546620a174" args="(const T &amp;x)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class Metric&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classCoverTree.html">CoverTree</a>&lt; T, Metric &gt;::remove           </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Removes one point, if it exists. 
<p>
Assumes that T can be tested for equality. <dl compact><dt><b>Returns:</b></dt><dd>True if a point was removed </dd></dl>

<p>
Definition at line <a class="el" href="covertree_8hh-source.html#l00129">129</a> of file <a class="el" href="covertree_8hh-source.html">covertree.hh</a>.
</div>
</div><p>
<a class="anchor" name="463f96b57029ba999c59f6e2a178a449"></a><!-- doxytag: member="CoverTree::remove_recursive" ref="463f96b57029ba999c59f6e2a178a449" args="(const T &amp;x, Node &amp;node)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class Metric&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classCoverTree.html">CoverTree</a>&lt; T, Metric &gt;::remove_recursive           </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCoverTree_1_1Node.html">Node</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>node</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Remove an instance from a subtree. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>The instance to remove </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>node</em>&nbsp;</td><td>The root of the subtree to search. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Whether x was a descendant of node (and was removed) </dd></dl>

<p>
Definition at line <a class="el" href="covertree_8hh-source.html#l00376">376</a> of file <a class="el" href="covertree_8hh-source.html">covertree.hh</a>.
<p>
Referenced by <a class="el" href="covertree_8hh-source.html#l00129">CoverTree&lt; boost::shared_ptr&lt; const StateVector &gt;, DistanceFunction &gt;::remove()</a>, and <a class="el" href="covertree_8hh-source.html#l00376">CoverTree&lt; boost::shared_ptr&lt; const StateVector &gt;, DistanceFunction &gt;::remove_recursive()</a>.
</div>
</div><p>
<hr><h2>Member Data Documentation</h2>
<a class="anchor" name="edb5f327de8b9407fcd533b4ef805bae"></a><!-- doxytag: member="CoverTree::d" ref="edb5f327de8b9407fcd533b4ef805bae" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class Metric&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Metric <a class="el" href="classCoverTree.html">CoverTree</a>&lt; T, Metric &gt;::<a class="el" href="classCoverTree.html#edb5f327de8b9407fcd533b4ef805bae">d</a><code> [private]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>
Definition at line <a class="el" href="covertree_8hh-source.html#l00452">452</a> of file <a class="el" href="covertree_8hh-source.html">covertree.hh</a>.
<p>
Referenced by <a class="el" href="covertree_8hh-source.html#l00280">CoverTree&lt; boost::shared_ptr&lt; const StateVector &gt;, DistanceFunction &gt;::insert_node()</a>, <a class="el" href="covertree_8hh-source.html#l00151">CoverTree&lt; boost::shared_ptr&lt; const StateVector &gt;, DistanceFunction &gt;::nearest()</a>, <a class="el" href="covertree_8hh-source.html#l00110">CoverTree&lt; boost::shared_ptr&lt; const StateVector &gt;, DistanceFunction &gt;::operator=()</a>, <a class="el" href="covertree_8hh-source.html#l00411">CoverTree&lt; boost::shared_ptr&lt; const StateVector &gt;, DistanceFunction &gt;::recursive_neighbors()</a>, and <a class="el" href="covertree_8hh-source.html#l00376">CoverTree&lt; boost::shared_ptr&lt; const StateVector &gt;, DistanceFunction &gt;::remove_recursive()</a>.
</div>
</div><p>
<a class="anchor" name="233fd62ce4a1995d5990d51375df2fe8"></a><!-- doxytag: member="CoverTree::duplicate" ref="233fd62ce4a1995d5990d51375df2fe8" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class Metric&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classCoverTree.html">CoverTree</a>&lt; T, Metric &gt;::<a class="el" href="classCoverTree.html#233fd62ce4a1995d5990d51375df2fe8">duplicate</a><code> [private]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>
Definition at line <a class="el" href="covertree_8hh-source.html#l00453">453</a> of file <a class="el" href="covertree_8hh-source.html">covertree.hh</a>.
<p>
Referenced by <a class="el" href="covertree_8hh-source.html#l00280">CoverTree&lt; boost::shared_ptr&lt; const StateVector &gt;, DistanceFunction &gt;::insert_node()</a>, and <a class="el" href="covertree_8hh-source.html#l00110">CoverTree&lt; boost::shared_ptr&lt; const StateVector &gt;, DistanceFunction &gt;::operator=()</a>.
</div>
</div><p>
<a class="anchor" name="e1e8f8eaedc4b7b385a41d6ca26db9fc"></a><!-- doxytag: member="CoverTree::root" ref="e1e8f8eaedc4b7b385a41d6ca26db9fc" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class Metric&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structCoverTree_1_1Node.html">Node</a>* <a class="el" href="classCoverTree.html">CoverTree</a>&lt; T, Metric &gt;::<a class="el" href="classCoverTree.html#e1e8f8eaedc4b7b385a41d6ca26db9fc">root</a><code> [private]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>
Definition at line <a class="el" href="covertree_8hh-source.html#l00451">451</a> of file <a class="el" href="covertree_8hh-source.html">covertree.hh</a>.
<p>
Referenced by <a class="el" href="covertree_8hh-source.html#l00272">CoverTree&lt; boost::shared_ptr&lt; const StateVector &gt;, DistanceFunction &gt;::clear()</a>, <a class="el" href="covertree_8hh-source.html#l00254">CoverTree&lt; boost::shared_ptr&lt; const StateVector &gt;, DistanceFunction &gt;::contents()</a>, <a class="el" href="covertree_8hh-source.html#l00280">CoverTree&lt; boost::shared_ptr&lt; const StateVector &gt;, DistanceFunction &gt;::insert_node()</a>, <a class="el" href="covertree_8hh-source.html#l00151">CoverTree&lt; boost::shared_ptr&lt; const StateVector &gt;, DistanceFunction &gt;::nearest()</a>, <a class="el" href="covertree_8hh-source.html#l00241">CoverTree&lt; boost::shared_ptr&lt; const StateVector &gt;, DistanceFunction &gt;::neighbors()</a>, <a class="el" href="covertree_8hh-source.html#l00110">CoverTree&lt; boost::shared_ptr&lt; const StateVector &gt;, DistanceFunction &gt;::operator=()</a>, <a class="el" href="covertree_8hh-source.html#l00265">CoverTree&lt; boost::shared_ptr&lt; const StateVector &gt;, DistanceFunction &gt;::print()</a>, <a class="el" href="covertree_8hh-source.html#l00129">CoverTree&lt; boost::shared_ptr&lt; const StateVector &gt;, DistanceFunction &gt;::remove()</a>, and <a class="el" href="covertree_8hh-source.html#l00105">CoverTree&lt; boost::shared_ptr&lt; const StateVector &gt;, DistanceFunction &gt;::~CoverTree()</a>.
</div>
</div><p>
<hr>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="covertree_8hh-source.html">covertree.hh</a></ul>
<hr size="1"><address style="align: right;"><small>Generated on Wed Dec 1 14:50:57 2010 for Fitted R-MAXQ by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.7 </small></address>
</body>
</html>
